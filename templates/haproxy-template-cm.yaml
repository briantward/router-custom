apiVersion: v1
data:
  haproxy-config.template: "{{/*\n    haproxy-config.cfg: contains the main config
    with helper backends that are used to terminate\n    \t\t\t\t\tencryption before
    finally sending to a host_be which is the backend that is the final\n    \t\t\t\t\tbackend
    for a route and contains all the endpoints for the service\n*/}}\n{{- define \"/var/lib/haproxy/conf/haproxy.config\"
    }}\n{{- $workingDir := .WorkingDir }}\n{{- $defaultDestinationCA := .DefaultDestinationCA
    }}\n{{- $dynamicConfigManager := .DynamicConfigManager }}\n{{- $router_ip_v4_v6_mode
    := env \"ROUTER_IP_V4_V6_MODE\" \"v4\" }}\n\n\n{{- /* A bunch of regular expressions.
    \ Each should be wrapped in (?:) so that it is safe to include bare */}}\n{{-
    /* quadPattern: Match a quad in an IP address; e.g. 123 */}}\n{{- $quadPattern
    := `(?:[0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])` -}}\n\n{{- /* ipPattern:
    Match an IPv4 address; e.g. 192.168.21.23 */}}\n{{- $ipPattern := printf `(?:%s\\.%s\\.%s\\.%s)`
    $quadPattern $quadPattern $quadPattern $quadPattern -}}\n\n{{- /* cidrPattern:
    Match an IP and network size in CIDR form; e.g. 192.168.21.23/24 */}}\n{{- $cidrPattern
    := printf `(?:%s(?:/(?:[0-9]|[1-2][0-9]|3[0-2]))?)` $ipPattern -}}\n\n{{- /* cidrListPattern:
    Match a space separated list of CIDRs; e.g. 192.168.21.23/24 192.10.2.12 */}}\n{{-
    $cidrListPattern := printf `(?:%s(?: +%s)*)` $cidrPattern $cidrPattern -}}\n\n{{-
    /* cookie name pattern: */}}\n{{- $cookieNamePattern := `[a-zA-Z0-9_-]+` -}}\n\n{{-
    $timeSpecPattern := `[1-9][0-9]*(us|ms|s|m|h|d)?` }}\n\n{{- /* hsts header in
    response: */}}\n{{- $hstsOptionalTokenPattern := `(?:includeSubDomains|preload)`
    }}\n{{- $hstsPattern := printf `(?:%[1]s[;])*max-age=(?:\\d+|\"\\d+\")(?:[;]%[1]s)*`
    \ $hstsOptionalTokenPattern -}}\n\n{{- /* setForwardedHeadersPattern matches valid
    options for how and when Forwarded: and X-Forwarded-*: headers are set. */}}\n{{-
    $setForwardedHeadersPattern := `(?:append|replace|if-none|never)` -}}\n\n{{- /*
    Route-Specific Annotations */}}\n{{- /* setForwardedHeadersAnnotation configures
    how Forwarded: and X-Forwarded-*: headers are set.  */}}\n{{- $setForwardedHeadersAnnotation
    := \"haproxy.router.openshift.io/set-forwarded-headers\" }}\n{{- /* setForwardedHeadersDefaultValue
    is the default value if a route does not have the setForwardedHeadersAnnotation
    annotation.  */}}\n{{- $setForwardedHeadersDefaultValue := firstMatch $setForwardedHeadersPattern
    (env \"ROUTER_SET_FORWARDED_HEADERS\" \"append\") \"append\" -}}\n\nglobal\n  maxconn
    {{env \"ROUTER_MAX_CONNECTIONS\" \"20000\"}}\n{{- $threads := env \"ROUTER_THREADS\"
    }}\n{{- if ne \"\" (firstMatch \"[1-9][0-9]*\" $threads) }}\n  nbthread {{ $threads
    }}\n{{-  end }}\n\n\n\n  daemon\n{{- with (env \"ROUTER_SYSLOG_ADDRESS\") }}\n
    \ log {{.}} {{env \"ROUTER_LOG_FACILITY\" \"local1\"}} {{env \"ROUTER_LOG_LEVEL\"
    \"warning\"}}\n{{- end}}\n  ca-base /etc/ssl\n  crt-base /etc/ssl\n  # TODO: Check
    if we can get reload to be faster by saving server state.\n  # server-state-file
    /var/lib/haproxy/run/haproxy.state\n  stats socket /var/lib/haproxy/run/haproxy.sock
    mode 600 level admin expose-fd listeners\n  stats timeout 2m\n\n  # Increase the
    default request size to be comparable to modern cloud load balancers (ALB: 64kb),
    affects\n  # total memory use when large numbers of connections are open.\n  tune.maxrewrite
    8192\n  tune.bufsize 32768\n\n  # Configure the TLS versions we support\n  ssl-default-bind-options
    ssl-min-ver {{env \"SSL_MIN_VERSION\" \"TLSv1.2\"}}\n    {{- if ne (env \"SSL_MAX_VERSION\"
    \"\") \"\" }} ssl-max-ver {{env \"SSL_MAX_VERSION\"}}{{ end }}\n\n# The default
    cipher suite can be selected from the three sets recommended by https://wiki.mozilla.org/Security/Server_Side_TLS,\n#
    or the user can provide one using the ROUTER_CIPHERS environment variable.\n#
    By default when a cipher set is not provided, intermediate is used.\n{{- if eq
    (env \"ROUTER_CIPHERS\" \"intermediate\") \"modern\" }}\n  # Modern cipher suite
    (no legacy browser support) from https://wiki.mozilla.org/Security/Server_Side_TLS\n
    \ tune.ssl.default-dh-param 2048\n  ssl-default-bind-ciphers ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256\n{{
    else }}\n\n  {{- if eq (env \"ROUTER_CIPHERS\" \"intermediate\") \"intermediate\"
    }}\n  # Intermediate cipher suite (default) from https://wiki.mozilla.org/Security/Server_Side_TLS\n
    \ tune.ssl.default-dh-param 2048\n  ssl-default-bind-ciphers ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS\n
    \ {{ else }}\n\n    {{- if eq (env \"ROUTER_CIPHERS\" \"intermediate\") \"old\"
    }}\n\n  # Old cipher suite (maximum compatibility but insecure) from https://wiki.mozilla.org/Security/Server_Side_TLS\n
    \ tune.ssl.default-dh-param 1024\n  ssl-default-bind-ciphers ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:ECDHE-RSA-DES-CBC3-SHA:ECDHE-ECDSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:DES-CBC3-SHA:HIGH:SEED:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!RSAPSK:!aDH:!aECDH:!EDH-DSS-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA:!SRP\n\n
    \   {{- else }}\n  # user provided list of ciphers (Colon separated list as seen
    above)\n  # the env default is not used here since we can't get here with empty
    ROUTER_CIPHERS\n  tune.ssl.default-dh-param 2048\n  ssl-default-bind-ciphers {{env
    \"ROUTER_CIPHERS\" \"ECDHE-ECDSA-CHACHA20-POLY1305\"}}\n    {{- end }}\n  {{-
    end }}\n{{- end }}\n\ndefaults\n  maxconn {{env \"ROUTER_MAX_CONNECTIONS\" \"20000\"}}\n\n{{-
    if ne (env \"ROUTER_SYSLOG_ADDRESS\") \"\" }}\n  {{- if ne (env \"ROUTER_SYSLOG_FORMAT\")
    \"\" }}\n  log-format {{env \"ROUTER_SYSLOG_FORMAT\"}}\n  {{- else }}\n  option
    httplog\n  {{- end }}\n  log global\n{{- end }}\n\n  # To configure custom default
    errors, you can either uncomment the\n  # line below (server ... 127.0.0.1:8080)
    and point it to your custom\n  # backend service or alternatively, you can send
    a custom 503 error.\n  #\n  # server openshift_backend 127.0.0.1:8080\n  errorfile
    503 /var/lib/haproxy/conf/error-page-503.http\n\n  timeout connect {{firstMatch
    $timeSpecPattern (env \"ROUTER_DEFAULT_CONNECT_TIMEOUT\") \"5s\"}}\n  timeout
    client {{firstMatch $timeSpecPattern (env \"ROUTER_DEFAULT_CLIENT_TIMEOUT\") \"30s\"}}\n
    \ timeout client-fin {{firstMatch $timeSpecPattern (env \"ROUTER_CLIENT_FIN_TIMEOUT\")
    \"1s\"}}\n  timeout server {{firstMatch $timeSpecPattern (env \"ROUTER_DEFAULT_SERVER_TIMEOUT\")
    \"30s\"}}\n  timeout server-fin {{firstMatch $timeSpecPattern (env \"ROUTER_DEFAULT_SERVER_FIN_TIMEOUT\")
    \"1s\"}}\n  timeout http-request {{firstMatch $timeSpecPattern (env \"ROUTER_SLOWLORIS_TIMEOUT\")
    \"10s\" }}\n  timeout http-keep-alive {{firstMatch $timeSpecPattern (env \"ROUTER_SLOWLORIS_HTTP_KEEPALIVE\")
    \"300s\" }}\n\n  # Long timeout for WebSocket connections.\n  timeout tunnel {{firstMatch
    $timeSpecPattern (env \"ROUTER_DEFAULT_TUNNEL_TIMEOUT\") \"1h\" }}\n\n{{- if isTrue
    (env \"ROUTER_ENABLE_COMPRESSION\") }}\n  compression algo gzip\n  compression
    type {{env \"ROUTER_COMPRESSION_MIME\" \"text/html text/plain text/css\"}}\n{{-
    end }}\n\n{{ if (gt .StatsPort -1) }}\nlisten stats\n  bind :{{if (gt .StatsPort
    0)}}{{.StatsPort}}{{else}}1936{{end}}\n  mode http\n  # Health check monitoring
    uri.\n  monitor-uri /healthz\n\n{{- if and (and (ne .StatsUser \"\") (ne .StatsPassword
    \"\")) (gt .StatsPort 0) }}\n  # Add your custom health check monitoring failure
    condition here.\n  # monitor fail if <condition>\n  stats enable\n  stats hide-version\n
    \ stats realm Haproxy\\ Statistics\n  stats uri /\n  stats auth {{.StatsUser}}:{{.StatsPassword}}\n{{-
    end }}\n{{- end }}\n\n{{ if .BindPorts -}}\nfrontend public\n    {{ if eq \"v4v6\"
    $router_ip_v4_v6_mode }}\n  bind :::{{env \"ROUTER_SERVICE_HTTP_PORT\" \"80\"}}
    v4v6\n    {{- else if eq \"v6\" $router_ip_v4_v6_mode }}\n  bind :::{{env \"ROUTER_SERVICE_HTTP_PORT\"
    \"80\"}} v6only\n    {{- else }}\n  bind :{{env \"ROUTER_SERVICE_HTTP_PORT\" \"80\"}}\n
    \   {{- end }}\n    {{- if isTrue (env \"ROUTER_USE_PROXY_PROTOCOL\") }} accept-proxy{{
    end }}\n  mode http\n  tcp-request inspect-delay 5s\n  tcp-request content accept
    if HTTP\n\n  {{- if (eq .StatsPort -1) }}\n  monitor-uri /_______internal_router_healthz\n
    \ {{- end }}\n\n  # Strip off Proxy headers to prevent HTTpoxy (https://httpoxy.org/)\n
    \ http-request del-header Proxy\n\n  # DNS labels are case insensitive (RFC 4343),
    we need to convert the hostname into lowercase\n  # before matching, or any requests
    containing uppercase characters will never match.\n  http-request set-header Host
    %[req.hdr(Host),lower]\n\n  # check if we need to redirect/force using https.\n
    \ acl secure_redirect base,map_reg(/var/lib/haproxy/conf/os_route_http_redirect.map)
    -m found\n  redirect scheme https if secure_redirect\n\n  use_backend %[base,map_reg(/var/lib/haproxy/conf/os_http_be.map)]\n\n
    \ default_backend openshift_default\n\n# public ssl accepts all connections and
    isn't checking certificates yet certificates to use will be\n# determined by the
    next backend in the chain which may be an app backend (passthrough termination)
    or a backend\n# that terminates encryption in this router (edge)\nfrontend public_ssl\n
    \   {{- if ne (env \"ROUTER_SYSLOG_ADDRESS\") \"\"}}\n  option tcplog\n    {{-
    end }}\n    {{ if eq \"v4v6\" $router_ip_v4_v6_mode }}\n  bind :::{{env \"ROUTER_SERVICE_HTTPS_PORT\"
    \"443\"}} v4v6\n    {{- else if eq \"v6\" $router_ip_v4_v6_mode }}\n  bind :::{{env
    \"ROUTER_SERVICE_HTTPS_PORT\" \"443\"}} v6only\n    {{- else }}\n  bind :{{env
    \"ROUTER_SERVICE_HTTPS_PORT\" \"443\"}}\n    {{- end }}\n    {{- if isTrue (env
    \"ROUTER_USE_PROXY_PROTOCOL\") }} accept-proxy{{ end }}\n  tcp-request  inspect-delay
    5s\n  tcp-request content accept if { req_ssl_hello_type 1 }\n\n  # if the connection
    is SNI and the route is a passthrough don't use the termination backend, just
    use the tcp backend\n  # for the SNI case, we also need to compare it in case-insensitive
    mode (by converting it to lowercase) as RFC 4343 says\n  acl sni req.ssl_sni -m
    found\n  acl sni_passthrough req.ssl_sni,lower,map_reg(/var/lib/haproxy/conf/os_sni_passthrough.map)
    -m found\n  use_backend %[req.ssl_sni,lower,map_reg(/var/lib/haproxy/conf/os_tcp_be.map)]
    if sni sni_passthrough\n\n  # if the route is SNI and NOT passthrough enter the
    termination flow\n  use_backend be_sni if sni\n\n  # non SNI requests should enter
    a default termination backend rather than the custom cert SNI backend since it\n
    \ # will not be able to match a cert to an SNI host\n  default_backend be_no_sni\n\n##########################################################################\n#
    TLS SNI\n#\n# When using SNI we can terminate encryption with custom certificates.\n#
    Certs will be stored in a directory and will be matched with the SNI host header\n#
    which must exist in the CN of the certificate.  Certificates must be concatenated\n#
    as a single file (handled by the plugin writer) per the haproxy documentation.\n#\n#
    Finally, check re-encryption settings and re-encrypt or just pass along the unencrypted\n#
    traffic\n##########################################################################\nbackend
    be_sni\n  server fe_sni 127.0.0.1:{{env \"ROUTER_SERVICE_SNI_PORT\" \"10444\"}}
    weight 1 send-proxy\n\nfrontend fe_sni\n  # terminate ssl on edge\n  bind 127.0.0.1:{{env
    \"ROUTER_SERVICE_SNI_PORT\" \"10444\"}} ssl\n    {{- if isTrue (env \"ROUTER_STRICT_SNI\")
    }} strict-sni {{ end }}\n    {{- \"\"}} crt {{firstMatch \".+\" .DefaultCertificate
    \"/var/lib/haproxy/conf/default_pub_keys.pem\"}}\n    {{- \"\"}} crt-list /var/lib/haproxy/conf/cert_config.map
    accept-proxy\n    {{- with (env \"ROUTER_MUTUAL_TLS_AUTH\") }}\n      {{- \"\"}}
    verify {{.}}\n      {{- with (env \"ROUTER_MUTUAL_TLS_AUTH_CA\") }} ca-file {{.}}
    {{ else }} ca-file /etc/ssl/certs/ca-bundle.trust.crt {{ end }}\n      {{- with
    (env \"ROUTER_MUTUAL_TLS_AUTH_CRL\") }} crl-file {{.}} {{ end }}\n    {{- end
    }}\n    {{- if isTrue (env \"ROUTER_ENABLE_HTTP2\") }} alpn h2,http/1.1{{ end
    }}\n  mode http\n\n  # Strip off Proxy headers to prevent HTTpoxy (https://httpoxy.org/)\n
    \ http-request del-header Proxy\n\n  # DNS labels are case insensitive (RFC 4343),
    we need to convert the hostname into lowercase\n  # before matching, or any requests
    containing uppercase characters will never match.\n  http-request set-header Host
    %[req.hdr(Host),lower]\n\n  {{ if ne (env \"ROUTER_MUTUAL_TLS_AUTH\" \"none\")
    \"none\" }}\n    {{- with (env \"ROUTER_MUTUAL_TLS_AUTH_FILTER\") }}\n  # If a
    mutual TLS auth subject filter environment variable is set, we deny\n  # requests
    if the DN field in the client certificate doesn't match that value.\n  # Please
    note that this match is a regular expression match.\n  # Example: For DN set to:
    /CN=header.test/ST=CA/C=US/O=Security/OU=OpenShift3,\n  #          A. ROUTER_MUTUAL_TLS_AUTH_FILTER=\"header.test\"
    \  OR\n  #             ROUTER_MUTUAL_TLS_AUTH_FILTER=\"head\"          OR\n  #
    \            ROUTER_MUTUAL_TLS_AUTH_FILTER=\"^/CN=header.test/ST=CA/C=US/O=Security/OU=OpenShift3$\"
    /* exact match example */\n  #             the filter would match the DN field
    (substring or exact match)\n  #             and the request will be passed on
    to the backend.\n  #          B. ROUTER_MUTUAL_TLS_AUTH_FILTER=\"legacy-web-client\",
    the request\n  #             will be rejected.\n  acl cert_cn_matches ssl_c_s_dn
    -m reg {{.}}\n  http-request deny unless cert_cn_matches\n    {{- end }}\n\n  #
    Add X-SSL* headers to pass client certificate information to the backend.\n  http-request
    set-header X-SSL                  %[ssl_fc]\n  http-request set-header X-SSL-Client-Verify
    \   %[ssl_c_verify]\n  http-request set-header X-SSL-Client-Serial    %{+Q}[ssl_c_serial,hex]\n
    \ http-request set-header X-SSL-Client-Version   %{+Q}[ssl_c_version]\n  http-request
    set-header X-SSL-Client-SHA1      %{+Q}[ssl_c_sha1,hex]\n  http-request set-header
    X-SSL-Client-DN        %{+Q}[ssl_c_s_dn]\n  http-request set-header X-SSL-Client-CN
    \       %{+Q}[ssl_c_s_dn(cn)]\n  http-request set-header X-SSL-Issuer           %{+Q}[ssl_c_i_dn]\n
    \ http-request set-header X-SSL-Client-NotBefore %{+Q}[ssl_c_notbefore]\n  http-request
    set-header X-SSL-Client-NotAfter  %{+Q}[ssl_c_notafter]\n  http-request set-header
    X-SSL-Client-DER       %{+Q}[ssl_c_der,base64]\n  {{- end }}\n\n  # map to backend\n
    \ # Search from most specific to general path (host case).\n  # Note: If no match,
    haproxy uses the default_backend, no other\n  #       use_backend directives below
    this will be processed.\n  use_backend %[base,map_reg(/var/lib/haproxy/conf/os_edge_reencrypt_be.map)]\n\n
    \ default_backend openshift_default\n\n##########################################################################\n#
    END TLS SNI\n##########################################################################\n\n##########################################################################\n#
    TLS NO SNI\n#\n# When we don't have SNI the only thing we can try to do is terminate
    the encryption\n# using our wild card certificate.  Once that is complete we can
    either re-encrypt\n# the traffic or pass it on to the backends\n##########################################################################\n#
    backend for when sni does not exist, or ssl term needs to happen on the edge\nbackend
    be_no_sni\n  server fe_no_sni 127.0.0.1:{{env \"ROUTER_SERVICE_NO_SNI_PORT\" \"10443\"}}
    weight 1 send-proxy\n\nfrontend fe_no_sni\n  # terminate ssl on edge\n  bind 127.0.0.1:{{env
    \"ROUTER_SERVICE_NO_SNI_PORT\" \"10443\"}} ssl crt {{firstMatch \".+\" .DefaultCertificate
    \"/var/lib/haproxy/conf/default_pub_keys.pem\"}} accept-proxy\n    {{- with (env
    \"ROUTER_MUTUAL_TLS_AUTH\") }}\n      {{- \"\"}} verify {{.}}\n      {{- with
    (env \"ROUTER_MUTUAL_TLS_AUTH_CA\") }} ca-file {{.}} {{ else }} ca-file /etc/ssl/certs/ca-bundle.trust.crt
    {{ end }}\n      {{- with (env \"ROUTER_MUTUAL_TLS_AUTH_CRL\") }} crl-file {{.}}
    {{ end }}\n    {{- end }}\n  mode http\n\n  # Strip off Proxy headers to prevent
    HTTpoxy (https://httpoxy.org/)\n  http-request del-header Proxy\n\n  # DNS labels
    are case insensitive (RFC 4343), we need to convert the hostname into lowercase\n
    \ # before matching, or any requests containing uppercase characters will never
    match.\n  http-request set-header Host %[req.hdr(Host),lower]\n\n  {{ if ne (env
    \"ROUTER_MUTUAL_TLS_AUTH\" \"none\") \"none\" }}\n    {{- with (env \"ROUTER_MUTUAL_TLS_AUTH_FILTER\")
    }}\n  # If a mutual TLS auth subject filter environment variable is set, we deny\n
    \ # requests if the DN field in the client certificate doesn't match that value.\n
    \ # Please note that this match is a regular expression match.\n  # See the config
    section 'frontend fe_sni' for examples.\n  acl cert_cn_matches ssl_c_s_dn -m reg
    {{.}}\n  http-request deny unless cert_cn_matches\n    {{- end }}\n\n  # Add X-SSL*
    headers to pass client certificate information to the backend.\n  http-request
    set-header X-SSL                  %[ssl_fc]\n  http-request set-header X-SSL-Client-Verify
    \   %[ssl_c_verify]\n  http-request set-header X-SSL-Client-Serial    %{+Q}[ssl_c_serial,hex]\n
    \ http-request set-header X-SSL-Client-Version   %{+Q}[ssl_c_version]\n  http-request
    set-header X-SSL-Client-SHA1      %{+Q}[ssl_c_sha1,hex]\n  http-request set-header
    X-SSL-Client-DN        %{+Q}[ssl_c_s_dn]\n  http-request set-header X-SSL-Client-CN
    \       %{+Q}[ssl_c_s_dn(cn)]\n  http-request set-header X-SSL-Issuer           %{+Q}[ssl_c_i_dn]\n
    \ http-request set-header X-SSL-Client-NotBefore %{+Q}[ssl_c_notbefore]\n  http-request
    set-header X-SSL-Client-NotAfter  %{+Q}[ssl_c_notafter]\n  http-request set-header
    X-SSL-Client-DER       %{+Q}[ssl_c_der,base64]\n  {{- end }}\n\n  # map to backend\n
    \ # Search from most specific to general path (host case).\n  # Note: If no match,
    haproxy uses the default_backend, no other\n  #       use_backend directives below
    this will be processed.\n  use_backend %[base,map_reg(/var/lib/haproxy/conf/os_edge_reencrypt_be.map)]\n\n
    \ default_backend openshift_default\n\n##########################################################################\n#
    END TLS NO SNI\n##########################################################################\n\nbackend
    openshift_default\n  mode http\n  option forwardfor\n  #option http-keep-alive\n
    \ option http-pretend-keepalive\n\n##-------------- app level backends ----------------\n{{/*\n
    \      1. If termination is not set: This is plain http -> http.  Create a be_http:<service>
    backend.\n          Incoming http traffic is terminated and sent as http to the
    pods.\n\n       2. If termination is type 'edge': This is https -> http.  Create
    a be_edge_http:<service> backend.\n          Incoming https traffic is terminated
    and sent as http to the pods.\n\n       3. If termination is type 'reencrypt':
    This is https -> https.  Create a be_secure:<service> backend.\n          Incoming
    https traffic is terminated and then sent as https to the pods.\n\n       4. If
    termination is type 'passthrough': This is https (or any SNI TLS connection) passthrough.\n
    \         Create a be_tcp:<service> backend.\n          Incoming traffic is inspected
    to get the hostname from the SNI header, but then all traffic is\n          passed
    through to the backend pod by just looking at the TCP headers.\n*/}}\n{{- range
    $cfgIdx, $cfg := .State }}\n  {{- if matchValues (print $cfg.TLSTermination) \"\"
    \"edge\" \"reencrypt\" }}\n\n# Plain http backend or backend with TLS terminated
    at the edge or a\n# secure backend with re-encryption.\nbackend {{genBackendNamePrefix
    $cfg.TLSTermination}}:{{$cfgIdx}}\n  mode http\n  option redispatch\n  {{- with
    $setHeaders := firstMatch $setForwardedHeadersPattern (index $cfg.Annotations
    $setForwardedHeadersAnnotation) $setForwardedHeadersDefaultValue }}\n    {{- if
    eq $setHeaders \"append\" }}\n  option forwardfor\n    {{- else if eq $setHeaders
    \"if-none\" }}\n  option forwardfor if-none\n    {{- end }}\n  {{- end}}\n\n    {{-
    with $balanceAlgo := firstMatch \"roundrobin|leastconn|source\" (index $cfg.Annotations
    \"haproxy.router.openshift.io/balance\") (env \"ROUTER_LOAD_BALANCE_ALGORITHM\")
    }}\n  balance {{ $balanceAlgo }}\n    {{- else }}\n  balance {{ if gt $cfg.ActiveServiceUnits
    1 }}roundrobin{{ else }}leastconn{{ end }}\n    {{- end }}\n    {{- with $ip_whiteList
    := firstMatch $cidrListPattern (index $cfg.Annotations \"haproxy.router.openshift.io/ip_whitelist\")
    }}\n      {{- if validateHAProxyWhiteList $ip_whiteList }}\n  acl whitelist src
    {{$ip_whiteList}}\n      {{- else }}\n\t{{- with $whiteListFileName := generateHAProxyWhiteListFile
    $workingDir $cfgIdx $ip_whiteList}}\n  acl whitelist src -f {{$whiteListFileName}}\n
    \       {{- end }}\n      {{- end }}\n  tcp-request content reject if !whitelist\n
    \   {{- end }}\n    {{- with $value := firstMatch $timeSpecPattern (index $cfg.Annotations
    \"haproxy.router.openshift.io/timeout\")}}\n  timeout server  {{$value}}\n    {{-
    end }}\n\n    {{- if isTrue (index $cfg.Annotations \"haproxy.router.openshift.io/rate-limit-connections\")
    }}\n  stick-table type ip size 100k expire 30s store conn_cur,conn_rate(3s),http_req_rate(10s)\n
    \ tcp-request content track-sc2 src\n      {{- if (isInteger (index $cfg.Annotations
    \"haproxy.router.openshift.io/rate-limit-connections.concurrent-tcp\")) }}\n  tcp-request
    content reject if { src_conn_cur ge  {{ index $cfg.Annotations \"haproxy.router.openshift.io/rate-limit-connections.concurrent-tcp\"
    }} }\n      {{- else }}\n  # concurrent TCP connections not restricted\n      {{-
    end }}\n\n      {{- if (isInteger (index $cfg.Annotations \"haproxy.router.openshift.io/rate-limit-connections.rate-tcp\"))
    }}\n  tcp-request content reject if { src_conn_rate ge {{ index $cfg.Annotations
    \"haproxy.router.openshift.io/rate-limit-connections.rate-tcp\" }} }\n      {{-
    else }}\n  #TCP connection rate not restricted\n      {{- end }}\n\n      {{-
    if (isInteger (index $cfg.Annotations \"haproxy.router.openshift.io/rate-limit-connections.rate-http\"))
    }}\n  tcp-request content reject if { src_http_req_rate ge {{ index $cfg.Annotations
    \"haproxy.router.openshift.io/rate-limit-connections.rate-http\" }} }\n      {{-
    else }}\n  #HTTP request rate not restricted\n      {{- end }}\n    {{- end }}\n\n
    \ timeout check 5000ms\n  {{- with $setHeaders := firstMatch $setForwardedHeadersPattern
    (index $cfg.Annotations $setForwardedHeadersAnnotation) $setForwardedHeadersDefaultValue
    }}\n    {{- if eq $setHeaders \"append\" }}\n    {{- /* X-Forwarded-For: is handled
    by \"option forwardfor\" above.  */}}\n  http-request add-header X-Forwarded-Host
    %[req.hdr(host)]\n  http-request add-header X-Forwarded-Port %[dst_port]\n  http-request
    add-header X-Forwarded-Proto http if !{ ssl_fc }\n  http-request add-header X-Forwarded-Proto
    https if { ssl_fc }\n  http-request add-header X-Forwarded-Proto-Version h2 if
    { ssl_fc_alpn -i h2 }\n      {{- if matchPattern \"(v4)?v6\" $router_ip_v4_v6_mode
    }}\n  # See the quoting rules in https://tools.ietf.org/html/rfc7239 for IPv6
    addresses (v4 addresses get translated to v6 when in hybrid mode)\n  http-request
    add-header Forwarded for=\\\"[%[src]]\\\";host=%[req.hdr(host)];proto=%[req.hdr(X-Forwarded-Proto)]\n
    \     {{- else }}\n  http-request add-header Forwarded for=%[src];host=%[req.hdr(host)];proto=%[req.hdr(X-Forwarded-Proto)]\n
    \     {{- end }}\n    {{- else if eq $setHeaders \"replace\" }}\n  http-request
    set-header X-Forwarded-For %[src]\n  http-request set-header X-Forwarded-Host
    %[req.hdr(host)]\n  http-request set-header X-Forwarded-Port %[dst_port]\n  http-request
    set-header X-Forwarded-Proto http if !{ ssl_fc }\n  http-request set-header X-Forwarded-Proto
    https if { ssl_fc }\n  http-request set-header X-Forwarded-Proto-Version h2 if
    { ssl_fc_alpn -i h2 }\n      {{- if matchPattern \"(v4)?v6\" $router_ip_v4_v6_mode
    }}\n  # See the quoting rules in https://tools.ietf.org/html/rfc7239 for IPv6
    addresses (v4 addresses get translated to v6 when in hybrid mode)\n  http-request
    set-header Forwarded for=\\\"[%[src]]\\\";host=%[req.hdr(host)];proto=%[req.hdr(X-Forwarded-Proto)]\n
    \     {{- else }}\n  http-request set-header Forwarded for=%[src];host=%[req.hdr(host)];proto=%[req.hdr(X-Forwarded-Proto)]\n
    \     {{- end }}\n    {{- else if eq $setHeaders \"if-none\" }}\n      {{- /*
    X-Forwarded-For: is handled by \"option forwardfor if-none\" above.  */}}\n  http-request
    set-header X-Forwarded-Host %[req.hdr(host)] if !{ req.hdr(X-Forwarded-Host) -m
    found }\n  http-request set-header X-Forwarded-Port %[dst_port] if !{ req.hdr(X-Forwarded-Port)
    -m found }\n  http-request set-header X-Forwarded-Proto http if !{ ssl_fc } !{
    req.hdr(X-Forwarded-Proto) -m found }\n  http-request set-header X-Forwarded-Proto
    https if { ssl_fc } !{ req.hdr(X-Forwarded-Proto) -m found }\n  http-request set-header
    X-Forwarded-Proto-Version h2 if { ssl_fc_alpn -i h2 } !{ req.hdr(X-Forwarded-Proto-Version)
    -m found }\n      {{- if matchPattern \"(v4)?v6\" $router_ip_v4_v6_mode }}\n  #
    See the quoting rules in https://tools.ietf.org/html/rfc7239 for IPv6 addresses
    (v4 addresses get translated to v6 when in hybrid mode)\n  http-request set-header
    Forwarded for=\\\"[%[src]]\\\";host=%[req.hdr(host)];proto=%[req.hdr(X-Forwarded-Proto)]
    if !{ req.hdr(Forwarded) -m found }\n      {{- else }}\n  http-request set-header
    Forwarded for=%[src];host=%[req.hdr(host)];proto=%[req.hdr(X-Forwarded-Proto)]
    if !{ req.hdr(Forwarded) -m found }\n      {{- end }}\n    {{- else if eq $setHeaders
    \"never\" }}\n      {{- /* No Forward headers set.  */}}\n    {{- end }}\n  {{-
    end}}\n\n  {{- if not (isTrue (index $cfg.Annotations \"haproxy.router.openshift.io/disable_cookies\"))
    }}\n  cookie {{firstMatch $cookieNamePattern (index $cfg.Annotations \"router.openshift.io/cookie_name\")
    (env \"ROUTER_COOKIE_NAME\" \"\") $cfg.RoutingKeyName}} insert indirect nocache
    httponly\n    {{- if and (matchValues (print $cfg.TLSTermination) \"edge\" \"reencrypt\")
    (ne $cfg.InsecureEdgeTerminationPolicy \"Allow\") }} secure\n    {{- end }}\n
    \ {{- end }}{{/* end disable cookies check */}}\n\n  {{- if matchValues (print
    $cfg.TLSTermination) \"edge\" \"reencrypt\" }}\n    {{- with $hsts := firstMatch
    $hstsPattern (index $cfg.Annotations \"haproxy.router.openshift.io/hsts_header\")
    }}\n  http-response set-header Strict-Transport-Security {{$hsts}}\n    {{- end
    }}{{/* hsts header */}}\n  {{- end }}{{/* is \"edge\" or \"reencrypt\" */}}\n\n
    \ {{- range $serviceUnitName, $weight := $cfg.ServiceUnitNames }}\n    {{- if
    ge $weight 0 }}{{/* weight=0 is reasonable to keep existing connections to backends
    with cookies as we can see the HTTP headers */}}\n      {{- with $serviceUnit
    := index $.ServiceUnits $serviceUnitName }}\n        {{- range $idx, $endpoint
    := processEndpointsForAlias $cfg $serviceUnit (env \"ROUTER_BACKEND_PROCESS_ENDPOINTS\"
    \"\") }}\n  server {{$endpoint.ID}} {{$endpoint.IP}}:{{$endpoint.Port}} cookie
    {{$endpoint.IdHash}} weight {{$weight}}\n          {{- if (eq $cfg.TLSTermination
    \"reencrypt\") }} ssl\n            {{- if $cfg.VerifyServiceHostname }} verifyhost
    {{ $serviceUnit.Hostname }}\n            {{- end }}\n            {{- if gt (len
    (index $cfg.Certificates (printf \"%s_pod\" $cfg.Host)).Contents) 0 }} verify
    required ca-file {{ $workingDir }}/cacerts/{{$cfgIdx}}.pem\n            {{- else
    }}\n              {{- if gt (len $defaultDestinationCA) 0 }} verify required ca-file
    {{ $defaultDestinationCA }}\n              {{- else }} verify none\n              {{-
    end }}\n            {{- end }}\n\n          {{- else if or (eq $cfg.TLSTermination
    \"\") (eq $cfg.TLSTermination \"edge\") }}\n          {{- end }}{{/* end type
    specific options*/}}\n\n            {{- if and (not $endpoint.NoHealthCheck) (gt
    $cfg.ActiveEndpoints 1) }} check inter {{firstMatch $timeSpecPattern (index $cfg.Annotations
    \"router.openshift.io/haproxy.health.check.interval\") (env \"ROUTER_BACKEND_CHECK_INTERVAL\")
    \"5000ms\"}}\n            {{- end }}{{/* end else no health check */}}\n            {{-
    with $podMaxConn := index $cfg.Annotations \"haproxy.router.openshift.io/pod-concurrent-connections\"
    }}\n              {{- if (isInteger (index $cfg.Annotations \"haproxy.router.openshift.io/pod-concurrent-connections\"))
    }} maxconn {{$podMaxConn}} {{- end }}\n            {{- end}}{{/* end pod-concurrent-connections
    annotation */}}\n\n          {{- end }}{{/* end if cg.TLSTermination */}}\n        {{-
    end }}{{/* end range processEndpointsForAlias */}}\n      {{- end }}{{/* end get
    serviceUnit from its name */}}\n  {{- end }}{{/* end range over serviceUnitNames
    */}}\n\n  {{- with $dynamicConfigManager }}\n    {{- if (eq $cfg.TLSTermination
    \"reencrypt\") }}\n      {{- range $idx, $serverName := $dynamicConfigManager.GenerateDynamicServerNames
    $cfgIdx }}\n  server {{$serverName}} 172.4.0.4:8765 weight 0 ssl disabled check
    inter {{firstMatch $timeSpecPattern (index $cfg.Annotations \"router.openshift.io/haproxy.health.check.interval\")
    (env \"ROUTER_BACKEND_CHECK_INTERVAL\") \"5000ms\"}}\n        {{- if gt (len (index
    $cfg.Certificates (printf \"%s_pod\" $cfg.Host)).Contents) 0 }} verify required
    ca-file {{ $workingDir }}/cacerts/{{$cfgIdx}}.pem\n        {{- else }}\n          {{-
    if gt (len $defaultDestinationCA) 0 }} verify required ca-file {{ $defaultDestinationCA
    }}\n          {{- else }} verify none\n          {{- end }}\n        {{- end }}\n
    \       {{- with $podMaxConn := index $cfg.Annotations \"haproxy.router.openshift.io/pod-concurrent-connections\"
    }}\n          {{- if (isInteger (index $cfg.Annotations \"haproxy.router.openshift.io/pod-concurrent-connections\"))
    }} maxconn {{$podMaxConn}} {{- end }}\n        {{- end}}{{/* end pod-concurrent-connections
    annotation */}}\n      {{- end }}{{/* end range over dynamic server names */}}\n\n
    \   {{- else }}\n      {{- with $name := $dynamicConfigManager.ServerTemplateName
    $cfgIdx }}\n        {{- with $size := $dynamicConfigManager.ServerTemplateSize
    $cfgIdx }}\n  dynamic-cookie-key {{$cfg.RoutingKeyName}}\n  server-template {{$name}}-
    1-{{$size}} 172.4.0.4:8765 check disabled\n        {{- end }}\n      {{- end }}\n
    \   {{- end }}\n  {{- end }}\n\n  {{- end }}{{/* end if tls==edge/none/reencrypt
    */}}\n\n  {{- if eq $cfg.TLSTermination \"passthrough\" }}\n\n# Secure backend,
    pass through\nbackend {{genBackendNamePrefix $cfg.TLSTermination}}:{{$cfgIdx}}\n
    \   {{- with $balanceAlgo := firstMatch \"roundrobin|leastconn|source\" (index
    $cfg.Annotations \"haproxy.router.openshift.io/balance\") (env \"ROUTER_TCP_BALANCE_SCHEME\"
    (env \"ROUTER_LOAD_BALANCE_ALGORITHM\")) }}\n  balance {{ $balanceAlgo }}\n    {{-
    else }}\n  balance {{ if gt $cfg.ActiveServiceUnits 1 }}roundrobin{{ else }}source{{
    end }}\n    {{- end }}\n    {{- with $ip_whiteList := firstMatch $cidrListPattern
    (index $cfg.Annotations \"haproxy.router.openshift.io/ip_whitelist\") }}\n      {{-
    if validateHAProxyWhiteList $ip_whiteList }}\n  acl whitelist src {{$ip_whiteList}}\n
    \     {{- else }}\n\t{{- with $whiteListFileName := generateHAProxyWhiteListFile
    $workingDir $cfgIdx $ip_whiteList}}\n  acl whitelist src -f {{$whiteListFileName}}\n
    \       {{- end }}\n      {{- end }}\n  tcp-request content reject if !whitelist\n
    \   {{- end }}\n    {{- with $value := firstMatch $timeSpecPattern (index $cfg.Annotations
    \"haproxy.router.openshift.io/timeout\")}}\n  timeout tunnel  {{$value}}\n    {{-
    end }}\n\n{{- if isTrue (index $cfg.Annotations \"haproxy.router.openshift.io/rate-limit-connections\")
    }}\n  stick-table type ip size 100k expire 30s store conn_cur,conn_rate(3s),http_req_rate(10s)\n
    \ tcp-request content track-sc2 src\n  {{- if (isInteger (index $cfg.Annotations
    \"haproxy.router.openshift.io/rate-limit-connections.concurrent-tcp\")) }}\n  tcp-request
    content reject if { src_conn_cur ge  {{ index $cfg.Annotations \"haproxy.router.openshift.io/rate-limit-connections.concurrent-tcp\"
    }} }\n  {{- else }}\n  # concurrent TCP connections not restricted\n  {{- end
    }}\n\n  {{- if (isInteger (index $cfg.Annotations \"haproxy.router.openshift.io/rate-limit-connections.rate-tcp\"))
    }}\n  tcp-request content reject if { src_conn_rate ge {{ index $cfg.Annotations
    \"haproxy.router.openshift.io/rate-limit-connections.rate-tcp\" }} }\n  {{- else
    }}\n  #TCP connection rate not restricted\n  {{- end }}\n{{- end }}\n\n  hash-type
    consistent\n  timeout check 5000ms\n    {{- range $serviceUnitName, $weight :=
    $cfg.ServiceUnitNames }}\n      {{- if ne $weight 0 }}{{/* drop connections where
    weight=0 as we can't use cookies, leaving only r-r and src-ip as dispatch methods
    and weight make no sense there */}}\n        {{- with $serviceUnit := index $.ServiceUnits
    $serviceUnitName }}\n          {{- range $idx, $endpoint := processEndpointsForAlias
    $cfg $serviceUnit (env \"ROUTER_BACKEND_PROCESS_ENDPOINTS\" \"\") }}\n  server
    {{$endpoint.ID}} {{$endpoint.IP}}:{{$endpoint.Port}} weight {{$weight}}\n            {{-
    if and (not $endpoint.NoHealthCheck) (gt $cfg.ActiveEndpoints 1) }} check inter
    {{firstMatch $timeSpecPattern (index $cfg.Annotations \"router.openshift.io/haproxy.health.check.interval\")
    (env \"ROUTER_BACKEND_CHECK_INTERVAL\") \"5000ms\"}}\n            {{- end }}{{/*
    end else no health check */}}\n            {{- with $podMaxConn := index $cfg.Annotations
    \"haproxy.router.openshift.io/pod-concurrent-connections\" }}\n              {{-
    if (isInteger (index $cfg.Annotations \"haproxy.router.openshift.io/pod-concurrent-connections\"))
    }} maxconn {{$podMaxConn}} {{- end }}\n            {{- end}}{{/* end pod-concurrent-connections
    annotation */}}\n\n          {{- end }}{{/* end range processEndpointsForAlias
    */}}\n        {{- end }}{{/* end get ServiceUnit from serviceUnitName */}}\n      {{-
    end }}{{/* end if weight != 0 */}}\n    {{- end }}{{/* end iterate over services*/}}\n\n
    \   {{- with $dynamicConfigManager }}\n      {{- with $name := $dynamicConfigManager.ServerTemplateName
    $cfgIdx }}\n        {{- with $size := $dynamicConfigManager.ServerTemplateSize
    $cfgIdx }}\n  dynamic-cookie-key {{$cfg.RoutingKeyName}}\n  server-template {{$name}}-
    1-{{$size}} 172.4.0.4:8765 check disabled\n        {{- end }}\n      {{- end }}\n
    \   {{- end }}\n\n  {{- end }}{{/*end tls==passthrough*/}}\n\n{{- end }}{{/* end
    loop over routes */}}\n{{- else }}\n# Avoiding binding ports until routing configuration
    has been synchronized.\n{{- end }}{{/* end bind ports after sync */}}\n{{ end
    }}{{/* end haproxy config template */}}\n\n{{/*---------------------------------
    END OF HAPROXY CONFIG, BELOW ARE MAPPING FILES ------------------------*/}}\n{{/*\n
    \   os_wildcard_domain.map: contains a mapping of wildcard hosts for a\n\t\t\t[sub]domain
    regexps. This map is used to check if\n\t\t\ta host matches a [sub]domain with
    has wildcard support.\n*/}}\n{{ define \"/var/lib/haproxy/conf/os_wildcard_domain.map\"
    -}}\n{{     if isTrue (env \"ROUTER_ALLOW_WILDCARD_ROUTES\") -}}\n{{         range
    $idx, $line := generateHAProxyMap . -}}\n{{$line}}\n{{         end -}}\n{{     end
    -}}{{/* end if router allows wildcard routes */ -}}\n{{ end -}}{{/* end wildcard
    domain map template */}}\n\n\n{{/*\n    os_http_be.map : contains a mapping of
    www.example.com -> <service name>. This map is used to discover the correct backend\n
    \                        by attaching a prefix: be_http for http routes\n                                                be_edge_http
    for edge routes with InsecureEdgeTerminationPolicy Allow\n                                                be_secure
    for reencrypt routes with InsecureEdgeTerminationPolicy Allow\n*/}}\n{{ define
    \"/var/lib/haproxy/conf/os_http_be.map\" -}}\n{{     range $idx, $line := generateHAProxyMap
    . -}}\n{{$line}}\n{{     end -}}\n{{ end -}}{{/* end http host map template */}}\n\n\n\n{{/*\n
    \   os_edge_reencrypt_be.map : contains a mapping of www.example.com -> <service
    name>. This map is similar to os_http_be.map but for tls routes.\n                         by
    attaching prefix: be_edge_http for edge terminated routes\n                                              be_secure
    for reencrypt routes\n*/}}\n{{ define \"/var/lib/haproxy/conf/os_edge_reencrypt_be.map\"
    -}}\n{{     range $idx, $line := generateHAProxyMap . -}}\n{{$line}}\n{{     end
    -}}\n{{ end -}}{{/* end edge http host map template */}}\n\n\n{{/*\n    os_route_http_redirect.map:
    contains a mapping of www.example.com -> <service name>.\n    Map is used to redirect
    insecure traffic to use a secure scheme (https)\n    if acls match for routes
    that have the insecure option set to redirect.\n*/}}\n{{ define \"/var/lib/haproxy/conf/os_route_http_redirect.map\"
    -}}\n{{     range $idx, $line := generateHAProxyMap . -}}\n{{$line}}\n{{     end
    -}}\n{{ end -}}{{/* end redirect http host map template */}}\n\n\n{{/*\n    os_tcp_be.map:
    contains a mapping of www.example.com -> <service name>.  This map is used to
    discover the correct backend\n                        by use_backend statements
    if acls are matched.\n*/}}\n{{ define \"/var/lib/haproxy/conf/os_tcp_be.map\"
    -}}\n{{     range $idx, $line := generateHAProxyMap . -}}\n{{$line}}\n{{     end
    -}}\n{{ end -}}{{/* end tcp host map template */}}\n\n\n{{/*\n    os_sni_passthrough.map:
    contains a mapping of routes that expect to have an sni header and should be passed\n
    \   \t\t\t\t\tthrough to the host_be.  Driven by the termination type of the ServiceAliasConfigs\n*/}}\n{{
    define \"/var/lib/haproxy/conf/os_sni_passthrough.map\" -}}\n{{     range $idx,
    $line := generateHAProxyMap . -}}\n{{$line}}\n{{     end -}}\n{{ end -}}{{/* end
    sni passthrough map template */}}\n\n{{/*\n    cert_config.map: contains a mapping
    of <cert-file> -> example.org\n                     This map is used to present
    the appropriate cert\n                     based on the sni header.\n    Note:
    It is sort of a reverse map for our case but the order\n          \"<cert>: <domain-set>\"
    is important as this allows us to use\n         wildcards and/or use a deny set
    with !<domain> in the future.\n*/}}\n{{ define \"/var/lib/haproxy/conf/cert_config.map\"
    -}}\n{{     range $idx, $line := generateHAProxyMap . -}}\n{{$line}}\n{{     end
    -}}\n{{ end -}}{{/* end cert_config map template */}}\n"
kind: ConfigMap
metadata:
  name: haproxy-template
  namespace: openshift-ingress
